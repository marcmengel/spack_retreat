1. It must be easy for an experiment to move many scripts from one "version" to another "version"

* stakeholders: DAQ, production, analysts

2.  Users must be able to access a stable base of software, and extend it with his own builds of higher-level packages.

* stakeholders: developers


----------------------

Terminology


----------------------

90% or more of the time spent on spack has gone into supporting builds for SL7.
SL7 is too old for spack to work well.

Eric points out that ROOT is in the official spack repo, not in the FNAL repo.
Can we decrease our support load by *not* considering ROOT to be a "CSAID-supplied package"?

Can we eventually consider dropping binary installations, and rather merely deliver YAML files/recipes.

We need reference builds of ... which packages? art, ots_daq

We should think of what requirements we want to place on a "spack release" before it becomes a "Fermi spack release".
We need to "vet" the releases from the spack team to verify they are workable for us.
Marc M has an example of a case when this was *not* automatic.
Part of our solution may be long-term support of our own fork of spack.

There is consensus that CSAID would not save effort by discontinuing the production of binary releases made available to the experiments.
This would result in a small savings of effort in the creation and distribution of some builds, and an larger increase in the support load because we are no longer carefully controlling the software mixes used by the experiments.

We may want to have a definition of the "current" version of any (sone or all) released software.
Marc M suggests doing this through the use of symbolic links to point to a specific version of an environment.


Experiments need to know how to make environments.

----------------------

1. **developer use case**: work on a new version of some part of the software stack, using lower-level packages that are pre-built and installed somehwere.
This work is done in a development environment.

2. **production use case**: use an installed code to run batch jobs at large scale.

3. **analyst use case**: take newly developed and thus not yet released code to run grid jobs.

4. **experiment release manager use cas**: take a set of tagged source code and build and distribute a new experiment release.

5. **CSAID release manager use case**: take a set of tagged source code and build and distribute a new CSAID release.
